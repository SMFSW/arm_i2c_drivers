/*!\file $CPNT$.h
** \author SMFSW
** \copyright MIT (c) 2017-2019, SMFSW
** \brief $CPNT$ Driver
** \details $CPNT$:
**/
/****************************************************************/
#ifndef __$CPNT$_H__
	#define __$CPNT$_H__

#ifdef __cplusplus
	extern "C" {
#endif

#include "sarmfsw.h"
#include "globals.h"

#include "I2C_component.h"
#include "I2C_peripheral.h"

#if defined(HAL_I2C_MODULE_ENABLED)
/****************************************************************/


#ifndef I2C_$CPNT$_NB
//! \note Define I2C_$CPNT$_NB in globals.h or at project to enable multiple peripherals of this type
#define I2C_$CPNT$_NB	1	//!< Number of $CPNT$ peripherals
#endif

// *****************************************************************************
// Section: Constants
// *****************************************************************************
#define $CPNT$_ADDR			0x00			//!< $CPNT$ address

#define $CPNT$_BASE_ADDR	$CPNT$_ADDR		//!< $CPNT$ Base address


// *****************************************************************************
// Section: Datas
// *****************************************************************************
extern I2C_slave_t $CPNT$_hal[I2C_$CPNT$_NB];	//!< $CPNT$ Slave structure


// *****************************************************************************
// Section: Types
// *****************************************************************************
/*!\enum $CPNT$_reg_map
** \brief Register map enum of $CPNT$
**/
typedef enum PACK__ $CPNT$_reg_map {
	$CPNT$__REG1 = 0,	//!< default value for reference
	$CPNT$__REG2,		//!< default value for reference
} $CPNT$_reg;


/*!\enum $CPNT$_enum
** \brief Values enum for $CPNT$
**/
typedef enum PACK__ $CPNT$_enum {
	$CPNT$__VAL1 = 0,	//!< default value for reference
	$CPNT$__VAL2,		//!< default value for reference
} $CPNT$_enum;


/*!\union u$CPNT$_REG__REG1
** \brief Union for REG1 register of $CPNT$
**/
typedef union u$CPNT$_REG__REG1 {
	uint8_t Byte;
	struct {
		uint8_t BIT0			:1;		//!< BIT0 description (LSB first)
		uint8_t 				:6;
		uint8_t BIT1			:1;		//!< BIT1 description (MSB last)
	} Bits;
} u$CPNT$_REG__REG1;


// *****************************************************************************
// Section: Interface Routines
// *****************************************************************************
/******************/
/*** Slave init ***/
/******************/

/*!\brief Initialization for $CPNT$ peripheral
** \param[in] idx - $CPNT$ index
** \param[in] hi2c - pointer to $CPNT$ I2C instance
** \param[in] devAddress - $CPNT$ device address
** \return FctERR - error code
**/
FctERR NONNULL__ $CPNT$_Init(const uint8_t idx, const I2C_HandleTypeDef * hi2c, const uint16_t devAddress);

/*!\brief Initialization for $CPNT$ peripheral
** \warning In case multiple devices (defined by I2C_$CPNT$_NB > 1), you shall use $CPNT$_Init instead
** \return FctERR - error code
**/
FctERR $CPNT$_Init_Single(void);


/************************/
/*** Low level access ***/
/************************/

/*!\brief I2C Write function for $CPNT$
** \param[in] pSlave - Pointer to I2C slave instance
** \param[in] data - pointer to write from
** \param[in] addr - Address to write to
** \param[in] nb - Number of bytes to write
** \return FctERR - error code
**/
FctERR NONNULL__ $CPNT$_Write(I2C_slave_t * pSlave, const uint8_t * data, const uint16_t addr, const uint16_t nb);


/*!\brief I2C Read function for $CPNT$
** \param[in] pSlave - Pointer to I2C slave instance
** \param[in,out] data - pointer to read to
** \param[in] addr - Address to read from
** \param[in] nb - Number of bytes to read
** \return FctERR - error code
**/
FctERR NONNULL__ $CPNT$_Read(I2C_slave_t * pSlave, uint8_t * data, const uint16_t addr, const uint16_t nb);


/****************************************************************/
#include "$CPNT$_proc.h"	// Include procedures
#include "$CPNT$_ex.h"		// Include extensions

#ifdef __cplusplus
	}
#endif

#endif
#endif /* __$CPNT$_H__ */
/****************************************************************/
